// File: init.c
/* ************************************************************************** */

#include "../include/cub3d.h"

t_map *init_map(void)
{
    t_map *map;

    map = (t_map *)malloc(sizeof(t_map));
    if (!map)
        return (NULL);
    map->grid = NULL;
    map->width = 0;
    map->height = 0;
    map->tex_no = NULL;
    map->tex_so = NULL;
    map->tex_we = NULL;
    map->tex_ea = NULL;
    map->floor_color = -1; // 未設定時は -1
    map->ceil_color = -1;
    return (map);
}

void setup_window(t_game *game)
{
    game->mlx = mlx_init();
    if (!game->mlx)
    {
        perror("mlx_init failed");
        exit(EXIT_FAILURE);
    }
    
    game->win = mlx_new_window(game->mlx, WIN_WIDTH, WIN_HEIGHT, "Cub3D");
    if (!game->win)
    {
        perror("mlx_new_window failed");
        exit(EXIT_FAILURE);
    }

    // 画面の背景をクリア
    mlx_clear_window(game->mlx, game->win);
}

void load_texture(t_game *game)
{
    game->img = mlx_xpm_file_to_image(game->mlx, TEXTURE_PATH, 
                                      &game->img_width, &game->img_height);
    if (!game->img)
    {
        perror("Failed to load texture");
        cleanup_and_exit(game);
    }
}

void draw_image(t_game *game)
{
    mlx_put_image_to_window(game->mlx, game->win, game->img, 100, 100);
}

// File: main.c
/* ************************************************************************** */

#include "../include/cub3d.h"

//初期化check用
// int main(void)
// {
//     t_map *map;

//     map = init_map();
//     if (!map)
//     {
//         printf("Error: Failed to initialize map->\n");
//         return (1);
//     }
    
//     // 初期化が正しく行われたか確認
//     printf("Map initialized:\n");
//     printf("Width: %d, Height: %d\n", map->width, map->height);
//     printf("Textures: NO=%p, SO=%p, WE=%p, EA=%p\n",
//            (void *)map->tex_no, (void *)map->tex_so,
//            (void *)map->tex_we, (void *)map->tex_ea);
//     printf("Floor Color: %d, Ceiling Color: %d\n",
//            map->floor_color, map->ceil_color);

//     // メモリ解放
//     free(map);
//     return (0);
// }

// パースチェック用
// int main(int argc, char **argv)
// {
//     t_map *map;

//     map = init_map();
//     if (!map)
//     {
//         printf("Error: Failed to initialize map->\n");
//         return (1);
//     }

//     if (argc != 2)
//     {
//         write(2, "Usage: ./cub3d <file.cub>\n", 26);
//         return (1);
//     }

//     // .cubファイルのパース
//     parse_cub_file(argv[1], map);

//     // パースされたデータの表示
//     write(1, "Parsed Data:\n", 13);
//     write(1, map->tex_no, ft_strlen(map->tex_no));
//     write(1, "\n", 1);
//     write(1, map->tex_so, ft_strlen(map->tex_so));
//     write(1, "\n", 1);
//     write(1, map->tex_we, ft_strlen(map->tex_we));
//     write(1, "\n", 1);
//     write(1, map->tex_ea, ft_strlen(map->tex_ea));
//     write(1, "\n", 1);
//     printf("Floor color: %d\n", map->floor_color);
//     printf("Ceiling color: %d\n", map->ceil_color);

//     // メモリ解放
//     free(map->tex_no);
//     free(map->tex_so);
//     free(map->tex_we);
//     free(map->tex_ea);

//     return (0);
// }

//mlx初期化
void cleanup_and_exit(t_game *game)
{
    if (game->img)
        mlx_destroy_image(game->mlx, game->img);
    if (game->win)
        mlx_destroy_window(game->mlx, game->win);
    free(game);
    exit(EXIT_SUCCESS);
}

int key_hook(int keycode, t_game *game)
{
    if (keycode == 65307) // ESCキーで終了
        cleanup_and_exit(game);
    return (0);
}

// int main(void)
// {
//     t_game *game = malloc(sizeof(t_game));
//     if (!game)
//     {
//         perror("malloc failed");
//         return (EXIT_FAILURE);
//     }
    
//     game->img = NULL;
//     game->win = NULL;

//     setup_window(game);
//     load_texture(game);
//     draw_image(game);

//     mlx_key_hook(game->win, key_hook, game);
//     mlx_loop(game->mlx);

//     return (0);
// }

int main(int argc, char **argv)
{
    t_map *map;
    t_game *game;

    if (argc != 2)
    {
        write(2, "Usage: ./cub3d <file.cub>\n", 26);
        return (1);
    }
    map = init_map();
    if (!map)
    {
        printf("Error: Failed to initialize map\n");
        return (1);
    }

    // .cubファイルのパース
    parse_cub_file(argv[1], map);

    // マップのバリデーションを実行
    if (!validate_map(map->grid))
    {
        free(map);
        return (1);
    }

    game = malloc(sizeof(t_game));
    if (!game)
    {
        perror("malloc failed");
        free(map);
        return (EXIT_FAILURE);
    }

    game->img = NULL;
    game->win = NULL;

    setup_window(game);
    load_texture(game);
    draw_image(game);

    mlx_key_hook(game->win, key_hook, game);
    mlx_loop(game->mlx);

    // メモリ解放
    free(map->tex_no);
    free(map->tex_so);
    free(map->tex_we);
    free(map->tex_ea);
    free(map);

    return (0);
}





// File: parse_map.c
/* ************************************************************************** */

#include "../include/cub3d.h"

// 空白文字をスキップ
char *skip_spaces(char *str)
{
    while (*str == ' ' || *str == '\t')
        str++;
    return (str);
}

// 文字列が特定のプレフィックスで始まっているか確認
int starts_with(char *line, char *prefix)
{
    int i = 0;
    while (prefix[i])
    {
        if (line[i] != prefix[i])
            return (0);
        i++;
    }
    return (1);
}

// テクスチャのパスを設定
void set_texture(char **dest, char *line)
{
    while (*line && *line != ' ')
        line++;
    line = skip_spaces(line);
    *dest = ft_strdup(line);
}

// RGBの色を解析
int parse_color(char *line)
{
    int r, g, b;
    r = g = b = 0;

    while (*line && (*line < '0' || *line > '9'))
        line++;
    r = ft_atoi(line);
    while (*line && *line != ',') line++;
    if (*line == ',') line++;

    g = ft_atoi(line);
    while (*line && *line != ',') line++;
    if (*line == ',') line++;

    b = ft_atoi(line);
    return ((r << 16) | (g << 8) | b);
}

// 1行を解析してデータを設定
void parse_line(t_map *map, char *line)
{
    if (starts_with(line, "NO"))
        set_texture(&map->tex_no, line + 2);
    else if (starts_with(line, "SO"))
        set_texture(&map->tex_so, line + 2);
    else if (starts_with(line, "WE"))
        set_texture(&map->tex_we, line + 2);
    else if (starts_with(line, "EA"))
        set_texture(&map->tex_ea, line + 2);
    else if (line[0] == 'F')
        map->floor_color = parse_color(line + 1);
    else if (line[0] == 'C')
        map->ceil_color = parse_color(line + 1);
}

// .cubファイルをパース
void parse_cub_file(char *filename, t_map *map)
{
    int fd;
    char buffer[BUFFER_SIZE + 1];
    size_t bytes_read;
    char *line;
    char *newline;

    fd = open(filename, O_RDONLY);
    if (fd == -1)
    {
        write(2, "Error opening file\n", 19);
        exit(1);
    }

    while ((bytes_read = read(fd, buffer, BUFFER_SIZE)) > 0)
    {
        buffer[bytes_read] = '\0';
        line = buffer;
        while (*line)
        {
            newline = line;
            while (*newline && *newline != '\n')
                newline++;
            if (*newline == '\n')
                *newline++ = '\0';

            parse_line(map, line);
            line = newline;
        }
    }
    close(fd);
}

// File: validate_map.c
/* ************************************************************************** */

#include "cub3d.h"

static int error(char *msg)
{
    write(2, "Error\n", 6);
    write(2, msg, ft_strlen(msg));
    write(2, "\n", 1);
    return (0);
}

// 1. マップが長方形かチェック
static int check_rectangular(char **map)
{
    int i;
    int width;

    if (!map || !map[0])
        return (0);
    width = ft_strlen(map[0]);
    i = 1;
    while (map[i])
    {
        if ((int)ft_strlen(map[i]) != width)
            return (0);
        i++;
    }
    return (1);
}

// 2. マップが壁（1）に囲まれているかチェック
static int check_closed_walls(char **map)
{
    int i, j;
    int width, height;

    height = 0;
    while (map[height])
        height++;
    width = ft_strlen(map[0]);

    // 上下の壁チェック
    for (j = 0; j < width; j++)
    {
        if (map[0][j] != '1' || map[height - 1][j] != '1')
            return (0);
    }

    // 左右の壁チェック
    for (i = 0; i < height; i++)
    {
        if (map[i][0] != '1' || map[i][width - 1] != '1')
            return (0);
    }
    return (1);
}

// 3. 不正な文字が含まれていないかチェック
static int check_valid_chars(char **map)
{
    int i, j;
    char c;

    i = 0;
    while (map[i])
    {
        j = 0;
        while (map[i][j])
        {
            c = map[i][j];
            if (c != '0' && c != '1' && c != 'N' && c != 'S' && 
                c != 'E' && c != 'W' && c != ' ')
                return (0);
            j++;
        }
        i++;
    }
    return (1);
}

// 4. 床 (0) やプレイヤー (N, S, E, W) の周囲が閉じているか
static int is_surrounded(char **map, int x, int y)
{
    if (x <= 0 || y <= 0 || !map[y + 1] || !map[y][x + 1])
        return (0);
    if (map[y - 1][x] == ' ' || map[y + 1][x] == ' ' ||
        map[y][x - 1] == ' ' || map[y][x + 1] == ' ')
        return (0);
    return (1);
}

static int check_surroundings(char **map)
{
    int i, j;

    i = 1;
    while (map[i + 1]) // 最初と最後の行はスキップ（すでに壁チェック済み）
    {
        j = 1;
        while (map[i][j + 1]) // 最初と最後の列はスキップ
        {
            if (map[i][j] == '0' || map[i][j] == 'N' ||
                map[i][j] == 'S' || map[i][j] == 'E' || map[i][j] == 'W')
            {
                if (!is_surrounded(map, j, i))
                    return (0);
            }
            j++;
        }
        i++;
    }
    return (1);
}

// 5. すべてのチェックを統合してマップを検証
int validate_map(char **map)
{
    if (!check_rectangular(map))
        return (error("Map is not rectangular"));
    if (!check_closed_walls(map))
        return (error("Map is not surrounded by walls"));
    if (!check_valid_chars(map))
        return (error("Map contains invalid characters"));
    if (!check_surroundings(map))
        return (error("Map contains open spaces"));
    return (1);
}


